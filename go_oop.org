#+TITLE:Go 객체 지향
#+STARTUP:showall

** Go 프로그램 구조
Go 는 struct 와 function 으로 이루어 진다. function 은 recever 를 통해 struct 와 연결할 수 있다. 

** Pointer
   - 포인터 선언
   - 연산 불가
   - 대입 불가

#+BEGIN_SRC golnag

var objPtr *int // 초기화는 nil
var objPtr = new(int) //메모리 주소 

//값의 대입
*numPtr = 1



// 값을 가져오기
fmt.Println(*objPtr) // 값을 가져오기

// 주소를 가져오기
fmt.Println(objPtr) // 포인터 변수에 저장된 메모리 출력
fmt.Println(&obj) // 변수가 저장된 메모리 주소 출력

#+END_SRC


** struct

#+BEGIN_SRC
  
  var obj = Rectangle{"obj","value"}

#+BEGIN_END

** func
   - 함수의 정의 위치는 제약이 없다.
   - 복수의 리턴 값을 가질 수 있다.
#+BEGIN_SRC
   // 복수의 리턴
   func Name(arg1,arg2  type) (return_type,return_type) {
   
    retrun arg1+arg2 ,arg2 - arg1
   }
#+END_SRC
   - 복수 리턴 변수에서 생략하고 싶은 변수의 경우 _ 를 이용해서 생략할 수 있다.
   - 리턴 변수를 지정할수 있다.
#+BEGIN_SRC
   //리턴 변수 지정 
   func Name(arg1,arg2  type) (ret_val return_type) {

   ret_val = arg1 + arg2
   
    retrun 
   }
#+END_SRC
   - 가변인자를 사용하여 함수의 유동적으로 매개변수를 사용할 수 있다.
#+BEGIN_SRC
   // 가변 인자를 사용 
   func Name(arg1  ...type) return_type {

   ret_val = arg1 + arg2
   
    retrun 
   }

  func main(){
r := name(1,2,3,4,5)
}
#+END_SRC

#+BEGIN_SRC
   // 가변 인자를 사용 
   func Name(arg1  ...type) return_type {

  fmt.println(arg1)
   
    retrun arg1[0]
   }

  func main(){
n := []int{1,2,3,4,5}
r := name(n...)
}
#+END_SRC
   - 재귀호출
     
#+BEGIN_SRC

#+BEGIN_SRC
   // 재귀 호출
 package main

import "fmt"

func factorial(n uint64) uint64 {
    if n == 0 {
      return 1
     }
     return n * factorial(n - 1)
}

func main(){
    fmt.Println(factorial(5))
}

#+END_SRC

   - 함수를 변수 저장
#+BEGIN_SRC

func sum(a int, b int) int {
  return a + b
}

func main()  {
   var hello func(a int, b int)int = sum

   world := sum


   fmt.Println(hello(1,2))
   fmt.Println(world(1,2))
}

#+END_SRC

   - 함수를 슬라이스와 맵에 저장
#+BEGIN_SRC
   func sum(a int, b int) int {
    return a +b 
   }

   func diff(a int, b int) int {
   return a - b
   }

   func main(){
   f := []func(int,int)int{sum,diff} // 함수를 저장 가능한 슬라이스 생성 
                                     // 함수로 초기화

   fmt.Println(f[0](1,2))
   fmt.Println(f[1](1,2))


   m := map[string]func(int,int)int{ //함수를 저장 할 수 있는 맵을 생성
                                     // 함수로 초기화 
   "sum":sum,
   "diff":diff,
   }

    fmt.Println(f["sum"](1,2))
    fmt.Println(f["diff"](1,2))

 }
#+END_SRC
   - 익명 함수 사용 (defer , 고루틴에 주로 사용)
#+BEGIN_SRC

import "fmt"

func main(){
   func() {
   fmt.Println("Hello, world!")
}()

func(s string) {
    fmt.Print(s)
}("Hello, world!")

r := func(a int, bint) int{
   return a + b
}(1,2)

fmt.Println(r)

}

#+END_SRC
    - 클로저(closure) 사용하기 
    - 클로저를 사용하면 지역변수가 소멸 되지 않고 나중에 함수가 호출할 때마다 계속 가져다 쓸수 있다. 클로저는 함수가 선언될 환경이 유지 된다.
#+BEGIN_SRC

func main() {
  a,b := 3,5

  f := func(x int) int{
  return a * x + b
}

 y := f(5)

  fmt.Println(y)
}

func main() {
  a,b := 3,5

  f := func(a ,b int) int{
  return a + b 
}

 r := sum(1,2)

  fmt.Println(r)
}

func calc() func(x int) int {
 a,b := 3,4

 return func(x int)int {
  return a*x+b // 클러저이므로 함수를 호출할 때마다 변수 a 와 b 의 값을 사용할 수 있음
}
 // 익명 함수를 리천
}

func main(){
  f:= calc() // calc 함수를 실행하여 리턴 값으로 나온 클로저를 변수에 저장
}

#+END_SRC
   

** 포인터의 활용
   - go 에서는 포인터형 변수를 선언 할수 있다.
   - 포인터형 변수는 new 함수로 메모리를 할당해야 한다.
   - 포인터 형 변수에는 *를 타입에 붙여서 선언 한다.
   - 포인터형 변수를 역참조 할때는 변수명에 *를 앞에 사용한다.
   - 일반 변수에 참조(&) 를 사용하면 포인터형 변수에 대입할 수 있다.
   - 포인터형 변수를 매개 변수로 사용할 경우 Call by reference 를 구현 할수 있다.

 

#+BEGIN_SRC
var numPtr *int = new(int)

fmt.Println(numPtr)// 메모리 주소가 출력 된다. 

*numPtr = 1 // 역참조로 포인터형 변수에 값을 대입 

fmt.Println(*numPtr) // 1 포인터형 변수에서 값을 가져 온다. 

num := 1

*numPtr = &num // 참조를 사용해서 값을 대입

func hello(n *int) {
  *n = 2
}

var in int = 1

hello (&n) // n 의 메모리 주소를 넘김

fmt.Println(n) // 2 출력 


#+END_SRC

** 구조체 임베딩 
   - Go 언어는 상속을 제공하지 않는다. 구조체 임베딩(Embedding) 을 사용하여 상속의 효과를 낼 수 있다.
   - 구조체 임베딩은 상속과 유사한 기능을 하지만 Go 언어 에서는 인터페이스를 활용하는 것을 권장한다.

    
#+BEGIN_SRC

type Person struct {
    name string
    age int
}


func (p *Person) greeting(){
   fmt.Println("Hello~")
}

type Student struct { 
   p Person // 변수명 지정 has-a 관계
   school string
   grade int
}

type Student struct {
   Person // 변수명을 지정하지 않음  구조체 임베딩 is-a 관계
   school string
   grade int
}


func main() {
    var s Student
    // 구조체 임베딩 미사용
    s.p.greeting() // Hello ~
    // 구조체 임베딩 사용시 
    s.Person.greeting() // Hello ~
    s.greeting() //Hello ~


}

// 매서드 오버라이드 
func (p *Student) greeting(){ 
    fmt.Println("Hello Students~")
}

func main(){
   s.Person.greeting() // Hello ~
    s.greeting() //Hello Students~

}

#+END_SRC

** 인터페이스
   - 인터페이스는 메서드의 선언의 집합이다.
   - 인터페이스에는 구현이 포함되지 않는다.

#+BEGIN_SRC

package main

import "fmt"

type hello interface {
 
}


func main() {
 var h hello // 인터페이스 선언
 fmt.Println(h) // <nil> 빈 인터페이스이므로 nil 이 출력됨
}



#+END_SRC

** 리시버 (receiver)
- 메소드 리시버 이름
메소드에 리시버의 이름은 그 정체서를 반영해야합니다.
종종 해당 유형의 하나 또는 두 글자 약어 (예 : "클라이언트"의 경우 "c"또는 "cl")입니다. "me", "this"또는 "self"와 같은 일반적인 이름, 메소드에 특별한 의미를 부여하는 객체 지향 언어의 일반적인 식별자를 사용하지 마십시오.
Go에서 메소드의 리시버는 또 다른 매개 변수이므로 그에 따라 이름을 지정해야합니다. 그 역할이 명백하고 문서적인 목적을 제공하지 않기 때문에, 이름은 메소드 인수와 같이 설명적일 필요는 없습니다. 리시버를 호출한경우 개발 변수로 다시 호출하지 마세요.

- 몇 가지 유용한 지침 :
리시버가 맵, func 또는 chan 인 경우 포인터를 사용하지 마십시오.
리시버가 슬라이스이고 메소드가 슬라이스를 다시 슬라이스하거나 재할 당하지 않는 경우 포인터를 사용하지 마십시오.
메소드가 리시버를 변경해야하는 경우 리시버는 포인터 여야합니다.
리시버가 sync.Mutex 또는 유사한 동기화 필드를 포함하는 구조체 인 경우 리시버는 복사를 피하기위한 포인터 여야합니다.
리시버가 큰 구조체 또는 배열이면 포인터 리시버가 더 효율적입니다.
함수 또는 메소드가 호울 될때 리시버를 변경 시키는 경우 값 유형은 메소드가 호춮될때 복사된 값을 사용하기 때문에 수정한 내용이 리시버에 적용되지 않습니다. 변경될 경우 포인터를 사용하세요
리시버가 값 유형 (예 : time.Time 유형과 같은)이고 가변 필드 및 포인터가 없거나 int 또는 string과 같은 단순한 기본 유형 인 작은 배열 또는 구조체 인 경우 생성될 수 있는 가비지의 양을 줄일수 있기 때문에 값 타입의 리시버가 더 좋습니다.
값 유형의 리시버가 메서드에 전달되면 힙에 할당하는 대신 스택 형 복사본을 사용할 수 있습니다. 마지막으로 의심스러운 경우 포인터 리시버를 사용하십시오.
